//@version=6
indicator("Intraday Opening Range Breakout", shorttitle = "ORB", overlay = true, max_lines_count = 500, max_labels_count = 500, max_boxes_count = 500)

// =============================================================================
// INPUTS
// =============================================================================

// Historical Display
showHist = input.bool(true, title = "Show Historical Data", group = "Historical Display", tooltip = "When enabled, displays all historical opening range data from previous sessions. Disable to only show current session data.")

// Opening Range Configuration
orTF = input.timeframe("60", title = "Opening Range Period", group = "Opening Range", tooltip = "Duration for calculating the opening range. Default: 60 minutes (1 hour). This period determines how long after market open to establish the high/low range.")

// Custom Range Settings
crTog = input.bool(false, title = "Use Custom Range", inline = "Custom", group = "Custom Range", tooltip = "Enable to override the default opening range with a custom time session.")
crSesh = input.session("0930-1030", title = "Custom Session", inline = "Custom", group = "Custom Range", tooltip = "Define custom trading session (format: HHMM-HHMM). Example: 0930-1030 for 9:30 AM to 10:30 AM.")
tz = input.string("UTC-5", title = "Timezone", group = "Custom Range", inline = "Custom", options = ["UTC-10", "UTC-8", "UTC-7", "UTC-6", "UTC-5", "UTC-4", "UTC-3", "UTC+0", "UTC+1", "UTC+2", "UTC+3", "UTC+3:30", "UTC+4", "UTC+5", "UTC+5:30", "UTC+5:45", "UTC+6", "UTC+6:30", "UTC+7", "UTC+8", "UTC+9", "UTC+9:30", "UTC+10", "UTC+11", "UTC+12", "UTC+12:45", "UTC+13"], tooltip = "Timezone for the custom session. UTC-5 is Eastern Time, UTC-8 is Pacific Time.")

// Breakout Signal Configuration
sigTog = input.bool(true, title = "Show Breakout Signals", group = "Breakout Signals", tooltip = "Display triangular signals when price breaks above/below the opening range levels.")
useBias = input.string("No Bias", title = "Signal Bias", options = ["No Bias", "Daily Bias"], group = "Breakout Signals", tooltip = "No Bias: Signals fire immediately on breakout.\nDaily Bias: Considers opening range color (bullish/bearish) - signals may be delayed until first target in opposite direction.") == "No Bias" ? false : true
sigSize = str.lower(input.string("Normal", title = "Signal Size", options = ["Tiny", "Small", "Normal", "Large", "Huge"], group = "Breakout Signals", tooltip = "Size of the breakout signal triangles displayed on the chart."))
upSigColor = input.color(#089981, title = "Bullish Signal Color", group = "Breakout Signals", inline = "SigColors", tooltip = "Color for upward breakout signals.")
downSigColor = input.color(#f23645, title = "Bearish Signal Color", group = "Breakout Signals", inline = "SigColors", tooltip = "Color for downward breakout signals.")

// Target Configuration
tTog = input.bool(true, title = "Show Targets", group = "Targets", tooltip = "Display target levels based on opening range width.")
tPer = input.float(50.0, minval = 1.0, maxval = 200.0, step = 5.0, title = "Target % of Range", group = "Targets", tooltip = "Percentage of opening range width used to calculate target distances. 50% means targets are placed at 50% intervals of the OR width.") * 0.01
tSrc = input.string("Close", title = "Target Trigger Source", options = ["Close", "Highs/Lows"], group = "Targets", tooltip = "Price source for target hits:\nClose: Uses closing price\nHighs/Lows: Uses actual high/low wicks")
tDispType = input.string("Adaptive", title = "Target Display Mode", options = ["Adaptive", "Extended"], group = "Targets", tooltip = "Adaptive: Shows/hides targets based on current price proximity\nExtended: All targets remain visible and extend to current bar")

// Session Trend Indicators
showSMA = input.bool(false, title = "Simple Moving Average", group = "Session Trend Indicators", inline = "SMA", tooltip = "Display session-based Simple Moving Average calculated from session start.")
smaLen = input.int(20, title = "Length", minval = 1, maxval = 200, group = "Session Trend Indicators", inline = "SMA")
smaColor = input.color(color.blue, title = "Color", group = "Session Trend Indicators", inline = "SMA")

showEMA = input.bool(false, title = "Exponential Moving Average", group = "Session Trend Indicators", inline = "EMA", tooltip = "Display session-based Exponential Moving Average with more weight on recent prices.")
emaLen = input.int(20, title = "Length", minval = 1, maxval = 200, group = "Session Trend Indicators", inline = "EMA")
emaColor = input.color(color.orange, title = "Color", group = "Session Trend Indicators", inline = "EMA")

showRMA = input.bool(false, title = "Relative Moving Average", group = "Session Trend Indicators", inline = "RMA", tooltip = "Display session-based Relative Moving Average (Wilder's smoothing).")
rmaLen = input.int(20, title = "Length", minval = 1, maxval = 200, group = "Session Trend Indicators", inline = "RMA")
rmaColor = input.color(color.purple, title = "Color", group = "Session Trend Indicators", inline = "RMA")

showWMA = input.bool(false, title = "Weighted Moving Average", group = "Session Trend Indicators", inline = "WMA", tooltip = "Display session-based Weighted Moving Average with linear weighting.")
wmaLen = input.int(20, title = "Length", minval = 1, maxval = 200, group = "Session Trend Indicators", inline = "WMA")
wmaColor = input.color(color.yellow, title = "Color", group = "Session Trend Indicators", inline = "WMA")

showVWAP = input.bool(false, title = "Anchor VWAP", group = "Session Trend Indicators", inline = "VWAP", tooltip = "Display session-based Anchor VWAP anchored to daily opening price.")
vwapColor = input.color(color.red, title = "Color", group = "Session Trend Indicators", inline = "VWAP")

// Table Configuration
showTable = input.bool(true, title = "Show Statistics Table", group = "Table", tooltip = "Display/hide the statistics table. Disable for cleaner chart view or mobile usage.")

// Session Status Colors
widthErrorColor = input.color(color.yellow, title = "Width Error Color", group = "Session Colors", inline = "Status1", tooltip = "Color for width error days (opening range < 0.2% of opening price)")
profitColor = input.color(color.green, title = "Profit Color", group = "Session Colors", inline = "Status1", tooltip = "Color for profitable breakout days")
lossColor = input.color(color.red, title = "Loss Color", group = "Session Colors", inline = "Status2", tooltip = "Color for loss breakout days")
errorColor = input.color(color.blue, title = "Error Color", group = "Session Colors", inline = "Status2", tooltip = "Color for error days (no breakout occurred)")

// Style Configuration
green = input.color(color.new(#089981, 60), title = "Bullish Target Color", group = "Style", inline = "Bull", tooltip = "Color for upward target lines and labels.")
red = input.color(color.new(#f23645, 60), title = "Bearish Target Color", group = "Style", inline = "Bear", tooltip = "Color for downward target lines and labels.")
orColor = input.color(#787b86, title = "OR Levels Color", group = "Style", inline = "Range", tooltip = "Color for opening range high/low lines and middle line.")
orFillColor = input.color(color.new(color.gray, 60), title = "OR Highlight Color", group = "Style", inline = "Range", tooltip = "Background highlight color for the opening range box.")
tStyle = input.string("___", title = "Target Line Style", options = ["___", "- - -", ". . ."], group = "Style", tooltip = "Visual style for target lines:\n___ = Solid\n- - - = Dashed\n. . . = Dotted")
txtSize = str.lower(input.string("Small", title = "Text Size", options = ["Tiny", "Small", "Normal", "Large", "Huge"], group = "Style", tooltip = "Size of labels and text displayed on targets and OR levels."))

// Constants
color invis = color.rgb(0, 0, 0, 100)

// =============================================================================
// ERROR HANDLING & VALIDATION
// =============================================================================

if timeframe.in_seconds(timeframe.period) >= timeframe.in_seconds("D")
    runtime.error("Timeframe too high! Please use a timeframe less than 1 day.")

if orTF == ""
    runtime.error("Opening Range timeframe cannot be empty.")

if crTog and str.length(crSesh) < 9
    runtime.error("Invalid custom session format. Use format: HHMM-HHMM")

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

// Zero-safe function to prevent division by zero
fz(_val) => _val == 0 ? 1 : _val

// Session-based moving average calculation
day_ma(_start, _type, source, length) =>
    bars_since_start = fz(ta.barssince(_start))
    valid_length = bars_since_start < length ? bars_since_start : length
    var float ma = na
    
    if _type == "EMA"
        k = 2 / (valid_length + 1)
        ma := (source * k) + (nz(ma[1]) * (1 - k))
    else if _type == "RMA"
        alpha = 1 / valid_length
        ma := alpha * source + (1 - alpha) * nz(ma[1])
    else if _type == "SMA"
        ma := ta.sma(source, valid_length)
    else if _type == "WMA"
        ma := ta.wma(source, valid_length)
    ma

// Session-based Anchor VWAP calculation anchored to daily open
session_anchor_vwap(_start) =>
    var float anchor_price = na
    var float sum_pv = 0.0
    var float sum_v = 0.0
    
    if _start
        anchor_price := open  // Anchor to session opening price
        sum_pv := 0.0
        sum_v := 0.0
    
    float vwap_val = na
    if not na(anchor_price)
        current_pv = close * volume
    sum_pv += current_pv
    sum_v += volume
    
        vwap_val := sum_v > 0 ? sum_pv / sum_v : anchor_price
    else
        vwap_val := close
        
    vwap_val

// Dash pattern for adaptive display
dash() => (bar_index / 2 - math.floor(bar_index / 2)) > 0

// Line style converter
linestyle(_input) =>
    _input == "___" ? line.style_solid :
     _input == "- - -" ? line.style_dashed :
     _input == ". . ." ? line.style_dotted : line.style_solid

// Get next integer value
get_1up(_val) => (_val - math.floor(_val)) > 0 ? int(math.floor(_val) + 1) : int(_val)

// =============================================================================
// DATA TYPES
// =============================================================================

type target
    line ln
    label lab

// =============================================================================
// STATE VARIABLES
// =============================================================================

// Arrays for targets and signals
var up_targs = array.new<target>()
var down_targs = array.new<target>()
var signals = array.new<label>()

// Session state tracking
var bool or_sesh = false
var bool or_token = false

// Opening Range values
var float orh = na  // Opening Range High
var float orl = na  // Opening Range Low
var float hst = na  // Highest since target
var float lst = na  // Lowest since target
var float prev_orm = na  // Previous Opening Range Middle

// Target counters
var int up_count = na
var int down_count = na

// Visual elements
var box or_bx = na
var target h_ln = target.new(na, na)
var target l_ln = target.new(na, na)
var linefill or_status_fill = na

// Bias and signal tracking
var int day_dir = 0
var bool down_check = false
var bool up_check = false
bool down_signal = false
bool up_signal = false

// Enhanced statistics tracking
var int days_counted = 0
var int width_error_days = 0
var int profit_days = 0
var int loss_days = 0
var int error_days = 0
var bool daily_broke_high = false
var bool daily_broke_low = false
var bool first_breakout_high = false  // Tracks if first breakout was high
var bool first_breakout_low = false   // Tracks if first breakout was low
var float session_open_price = na
var table stats_table = na
var bool session_processed = false
var bool is_tradable_day = false
var label day_outcome_label = na
var bool width_error_shown = false
var string current_session_status = "Pending"

// =============================================================================
// CORE CALCULATIONS
// =============================================================================

// Opening Range metrics
float orm = math.avg(orh, orl)  // Opening Range Middle
float orw = math.abs(orh - orl)  // Opening Range Width

// Target source selection
float h_src = tSrc == "Close" ? close : high
float l_src = tSrc == "Close" ? close : low

// Performance optimization
max_bars_back(close, 500)
max_bars_back(daily_broke_high, 100)
max_bars_back(daily_broke_low, 100)

// =============================================================================
// SESSION DETECTION
// =============================================================================

bool new_tf = timeframe.change(orTF)

if crTog
    or_sesh := not na(time(timeframe.period, crSesh, tz))
else 
    if session.isfirstbar
        or_sesh := true
    else if not session.isfirstbar and new_tf
        or_sesh := false

bool or_start = or_sesh and not or_sesh[1]
bool or_end = or_sesh[1] and not or_sesh

// =============================================================================
// SESSION START PROCESSING
// =============================================================================

if or_start
    // Process previous session statistics
    if not session_processed and or_token[1] and days_counted >= 0
        days_counted += 1
        
        // Get previous session data
        float prev_close = close[1]
        float prev_orh = orh[1] 
        float prev_orl = orl[1]
        bool prev_broke_high = daily_broke_high[1]
        bool prev_broke_low = daily_broke_low[1]
        float prev_session_open = session_open_price[1]
        
        // Validate previous session data
        if not na(prev_orh) and not na(prev_orl) and prev_orh != prev_orl
            if not na(prev_session_open)
                float width_threshold = prev_session_open * 0.002  // 0.2% threshold
                float or_range = prev_orh - prev_orl
                
                if or_range < width_threshold
                    width_error_days += 1
                    if not na(prev_orh)
                        label.new(bar_index - 1, prev_orh + (prev_orh - prev_orl) * 0.1, "W", style=label.style_label_down, color=widthErrorColor, textcolor=color.white, size=size.tiny, tooltip="Width Error: Opening range < 0.2%")
                else
                    // Analyze breakout outcomes using same logic as current session
                    if prev_broke_high or prev_broke_low
                        // For historical data, we don't have first_breakout tracking, so use simplified logic
                        bool prev_is_profit = false
                        
                        if prev_broke_high and prev_broke_low
                            // Both breakouts occurred - without first breakout tracking, prioritize high breakout
                            // This is a limitation for historical data but maintains consistency
                            prev_is_profit := prev_close >= prev_orl
                        else if prev_broke_high
                            // High breakout only - profit if close >= orl
                            prev_is_profit := prev_close >= prev_orl
                        else if prev_broke_low
                            // Low breakout only - profit if close <= orh
                            prev_is_profit := prev_close <= prev_orh
                        
                        if prev_is_profit
                            profit_days += 1
                            if not na(prev_orh)
                                label.new(bar_index - 1, prev_orh + (prev_orh - prev_orl) * 0.1, "P", style=label.style_label_down, color=profitColor, textcolor=color.white, size=size.tiny, tooltip="Profit Day: Successful breakout")
                        else
                            loss_days += 1
                            if not na(prev_orh)
                                label.new(bar_index - 1, prev_orh + (prev_orh - prev_orl) * 0.1, "L", style=label.style_label_down, color=lossColor, textcolor=color.white, size=size.tiny, tooltip="Loss Day: Failed breakout")
                    else
                        // No breakout occurred
                        error_days += 1
                        if not na(prev_orh)
                            label.new(bar_index - 1, prev_orh + (prev_orh - prev_orl) * 0.1, "E", style=label.style_label_down, color=errorColor, textcolor=color.white, size=size.tiny, tooltip="Error Day: No breakout")
    
    // Clean up previous session visuals
    for targ in up_targs
        if showHist == false
            targ.ln.delete()
        targ.lab.delete()

    for targ in down_targs
        if showHist == false
            targ.ln.delete()
        targ.lab.delete()

    for lab in signals
        if showHist == false
            lab.delete()

    if showHist == false
        or_bx.delete()
        h_ln.ln.delete()
        l_ln.ln.delete()
        if not na(or_status_fill)
            linefill.delete(or_status_fill)

    h_ln.lab.delete()
    l_ln.lab.delete()
    up_targs.clear()
    down_targs.clear()
    
    if not na(day_outcome_label) and showHist == false
        day_outcome_label.delete()
    day_outcome_label := na

    // Reset status fill
    or_status_fill := na

    // Initialize new session
    orh := high
    orl := low
    prev_orm := orm[1]
    up_count := 0
    down_count := 0
    up_check := true
    down_check := true
    
    // Reset tracking variables
    daily_broke_high := false
    daily_broke_low := false
    first_breakout_high := false
    first_breakout_low := false
    session_open_price := open
    session_processed := false
    is_tradable_day := false
    width_error_shown := false
    current_session_status := "Pending"

    or_bx := box.new(bar_index, high, bar_index, low, bgcolor = orFillColor, border_width = 0)
    or_token := false

// =============================================================================
// DURING SESSION PROCESSING
// =============================================================================

if or_sesh
    if high > orh
        orh := high
    if low < orl
        orl := low
    or_bx.set_top(orh)
    or_bx.set_bottom(orl)
    or_bx.set_right(bar_index)
    if orh != orl
        or_token := true
        
// =============================================================================
// SESSION END PROCESSING
// =============================================================================

if or_end and or_token
    h_ln := target.new(line.new(bar_index, orh, bar_index, orh, color = orColor), label.new(bar_index, orh, text = "ORH", tooltip = str.tostring(orh, format.mintick), style = label.style_label_left, color = invis, textcolor = color.new(orColor, 0), size = txtSize))
    
    l_ln := target.new(line.new(bar_index, orl, bar_index, orl, color = orColor), label.new(bar_index, orl, text = "ORL", tooltip = str.tostring(orl, format.mintick), style = label.style_label_left, color = invis, textcolor = color.new(orColor, 0), size = txtSize))
    
    hst := orh + (orw * tPer)
    lst := orl - (orw * tPer)

    day_dir := orm > prev_orm ? 1 : orm < prev_orm ? -1 : 0
    
    // Check tradability immediately after session
    if not na(session_open_price) and not na(orh) and not na(orl)
        float width_threshold = session_open_price * 0.002
        float or_range = orh - orl
        is_tradable_day := or_range >= width_threshold
        
        if not is_tradable_day and not width_error_shown
            day_outcome_label := label.new(bar_index, orh + (orh - orl) * 0.1, "W", style=label.style_label_down, color=widthErrorColor, textcolor=color.white, size=size.tiny, tooltip="Width Error: Opening range < 0.2%")
            width_error_shown := true
            current_session_status := "Width Error"

// =============================================================================
// BREAKOUT TRACKING
// =============================================================================

if not or_sesh and or_token and not na(orh) and not na(orl) and is_tradable_day
    if close > orh and not daily_broke_high
        daily_broke_high := true
        if not first_breakout_high and not first_breakout_low
            first_breakout_high := true
        current_session_status := "Broke High"
    if close < orl and not daily_broke_low
        daily_broke_low := true
        if not first_breakout_high and not first_breakout_low
            first_breakout_low := true
        current_session_status := "Broke Low"
    
    // Update status based on current situation
    if daily_broke_high and daily_broke_low
        current_session_status := "Both Breakouts"
    else if daily_broke_high
        current_session_status := close >= orl ? "Potential Profit (High)" : "Potential Loss (High)"
    else if daily_broke_low
        current_session_status := close <= orh ? "Potential Profit (Low)" : "Potential Loss (Low)"
    else if not daily_broke_high and not daily_broke_low
        current_session_status := "No Breakout Yet"

// Final session processing
if session.islastbar and or_token and not session_processed and is_tradable_day
    if not daily_broke_high and not daily_broke_low
        current_session_status := "Error Day (No Breakout)"

if barstate.islast and or_token and not session_processed
    days_counted += 1
    session_processed := true
    
    if not na(session_open_price) and not na(orh) and not na(orl)
        float width_threshold = session_open_price * 0.002
        float or_range = orh - orl
        
        if or_range < width_threshold
            width_error_days += 1
            current_session_status := "Width Error"
            if na(day_outcome_label)
                day_outcome_label := label.new(bar_index, orh + (orh - orl) * 0.1, "W", 
                                              style=label.style_label_down, color=widthErrorColor, textcolor=color.white, 
                                              size=size.tiny, tooltip="Width Error: Opening range < 0.2%")
        else
            if daily_broke_high or daily_broke_low
                // Use same logic as background fill - prioritize first breakout when both occur
                bool is_profit = false
                
                if daily_broke_high and daily_broke_low
                    // Both breakouts occurred - use first breakout for profit/loss calculation
                    if first_breakout_high
                        // First breakout was high - profit if close >= orl
                        is_profit := close >= orl
                    else if first_breakout_low
                        // First breakout was low - profit if close <= orh
                        is_profit := close <= orh
                else if daily_broke_high
                    // High breakout only - profit if close >= orl
                    is_profit := close >= orl
                else if daily_broke_low
                    // Low breakout only - profit if close <= orh
                    is_profit := close <= orh
                
                if is_profit
                    profit_days += 1
                    current_session_status := "Profit Day"
                    if na(day_outcome_label)
                        day_outcome_label := label.new(bar_index, orh + (orh - orl) * 0.1, "P", 
                                                      style=label.style_label_down, color=profitColor, textcolor=color.white, 
                                                      size=size.tiny, tooltip="Profit Day: Successful breakout")
                else
                    loss_days += 1
                    current_session_status := "Loss Day"
                    if na(day_outcome_label)
                        day_outcome_label := label.new(bar_index, orh + (orh - orl) * 0.1, "L", 
                                                      style=label.style_label_down, color=lossColor, textcolor=color.white, 
                                                      size=size.tiny, tooltip="Loss Day: Failed breakout")
            else
                error_days += 1
                current_session_status := "Error Day"
                if na(day_outcome_label)
                    day_outcome_label := label.new(bar_index, orh + (orh - orl) * 0.1, "E", 
                                                  style=label.style_label_down, color=errorColor, textcolor=color.white, 
                                                  size=size.tiny, tooltip="Error Day: No breakout")

// =============================================================================
// LEVEL EXTENSIONS
// =============================================================================

if not or_sesh and or_token
    h_ln.ln.set_x2(bar_index)
    l_ln.ln.set_x2(bar_index)
    h_ln.lab.set_x(bar_index)
    l_ln.lab.set_x(bar_index)

// =============================================================================
// SESSION STATUS OPENING RANGE FILL
// =============================================================================

// Opening range fill coloring based on session status (only after opening range ends)
if not or_sesh and or_token
    // Delete previous fill if it exists
    if not na(or_status_fill)
        linefill.delete(or_status_fill)
        or_status_fill := na
    
    // Check if we have valid session data and OR lines exist
    if not na(session_open_price) and not na(orh) and not na(orl) and not na(h_ln) and not na(l_ln)
        float width_threshold = session_open_price * 0.002
        float or_range = orh - orl
        
        color session_fill_color = color(na)
        if or_range < width_threshold
            // Width error - use custom width error color
            session_fill_color := color.new(widthErrorColor, 85)
        else if is_tradable_day
            // Valid trading day - check breakout status
            if daily_broke_high and daily_broke_low
                // Both breakouts occurred - use first breakout for profit/loss calculation
                if first_breakout_high
                    // First breakout was high - green if profitable, red if loss
                    session_fill_color := close >= orl ? color.new(profitColor, 85) : color.new(lossColor, 85)
                else if first_breakout_low
                    // First breakout was low - green if profitable, red if loss
                    session_fill_color := close <= orh ? color.new(profitColor, 85) : color.new(lossColor, 85)
                else
                    // Fallback - no fill (shouldn't happen)
                    session_fill_color := color(na)
            else if daily_broke_high
                // High breakout only - green if profitable, red if loss
                session_fill_color := close >= orl ? color.new(profitColor, 85) : color.new(lossColor, 85)
            else if daily_broke_low
                // Low breakout only - green if profitable, red if loss
                session_fill_color := close <= orh ? color.new(profitColor, 85) : color.new(lossColor, 85)
            else
                // No breakout occurred - use custom error color
                session_fill_color := color.new(errorColor, 85)
        
        // Create fill between OR high and low lines if color is set
        if not na(session_fill_color)
            or_status_fill := linefill.new(h_ln.ln, l_ln.ln, session_fill_color)

// =============================================================================
// TARGET CALCULATIONS
// =============================================================================

if h_src > hst
    hst := h_src
if l_src < lst
    lst := l_src

int up_max = get_1up((hst - orh) / (orw * tPer))
int down_max = get_1up((orl - lst) / (orw * tPer))

int up_cur = math.max(0, get_1up((h_src - orh) / (orw * tPer)))
int down_cur = math.max(0, get_1up((orl - l_src) / (orw * tPer)))

// =============================================================================
// SIGNAL DETECTION
// =============================================================================

// Signal logic for tradable days only
if is_tradable_day and (close > orm and down_check == false)
    down_check := true

bool xdown = ta.crossunder(close, orl)
bool xdown2 = ta.crossunder(close, orl - orw * tPer)
if is_tradable_day and (useBias ? ((day_dir != 1 and xdown) or (day_dir == 1 and xdown2)) : ta.crossunder(close, orl)) and down_check
    down_signal := true
    down_check := false

if is_tradable_day and (close < orm and up_check == false)
    up_check := true

bool xup = ta.crossover(close, orh)
bool xup2 = ta.crossover(close, orh + orw * tPer)
if is_tradable_day and (useBias ? ((day_dir != -1 and xup) or (day_dir == -1 and xup2)) : ta.crossover(close, orh)) and up_check
    up_signal := true
    up_check := false

// =============================================================================
// SESSION TREND INDICATORS
// =============================================================================

float session_sma = showSMA ? day_ma(or_start, "SMA", close, smaLen) : na
float session_ema = showEMA ? day_ma(or_start, "EMA", close, emaLen) : na
float session_rma = showRMA ? day_ma(or_start, "RMA", close, rmaLen) : na
float session_wma = showWMA ? day_ma(or_start, "WMA", close, wmaLen) : na

// Session Anchor VWAP calculation
float session_anchor_vwap_val = showVWAP ? session_anchor_vwap(or_start) : na

// =============================================================================
// DISPLAY & VISUALIZATION
// =============================================================================

// Statistics Table
if barstate.islast and showTable
    if not na(stats_table)
        table.delete(stats_table)
    
    // Calculate percentages
    float width_error_rate = days_counted > 0 ? math.round((width_error_days / days_counted) * 100, 2) : 0.0
    float profit_rate = days_counted > 0 ? math.round((profit_days / days_counted) * 100, 2) : 0.0
    float loss_rate = days_counted > 0 ? math.round((loss_days / days_counted) * 100, 2) : 0.0
    float error_rate = days_counted > 0 ? math.round((error_days / days_counted) * 100, 2) : 0.0
    
    bool is_current_session = or_token and not session_processed
    
    // Create statistics table
    stats_table := table.new(position.top_right, 2, 6, bgcolor=color.white, border_width=1, frame_width=1, frame_color=color.gray)
    
    // Table headers and data
    table.cell(stats_table, 0, 0, "ORB Statistics", text_color=color.black, text_size=size.normal, bgcolor=color.gray)
    table.cell(stats_table, 1, 0, "", text_color=color.black, text_size=size.normal, bgcolor=color.gray)
    
    table.cell(stats_table, 0, 1, "Days Counted:", text_color=color.black, text_size=size.small)
    table.cell(stats_table, 1, 1, str.tostring(days_counted + (is_current_session ? 1 : 0)), text_color=color.black, text_size=size.small)
    
    table.cell(stats_table, 0, 2, "Width Error:", text_color=color.black, text_size=size.small)
    table.cell(stats_table, 1, 2, str.tostring(width_error_days) + " (" + str.tostring(width_error_rate, "#.##") + "%)", text_color=widthErrorColor, text_size=size.small)
    
    table.cell(stats_table, 0, 3, "Profit Days:", text_color=color.black, text_size=size.small)
    table.cell(stats_table, 1, 3, str.tostring(profit_days) + " (" + str.tostring(profit_rate, "#.##") + "%)", text_color=profitColor, text_size=size.small)
    
    table.cell(stats_table, 0, 4, "Loss Days:", text_color=color.black, text_size=size.small)
    table.cell(stats_table, 1, 4, str.tostring(loss_days) + " (" + str.tostring(loss_rate, "#.##") + "%)", text_color=lossColor, text_size=size.small)
    
    table.cell(stats_table, 0, 5, "Error Days:", text_color=color.black, text_size=size.small)
    table.cell(stats_table, 1, 5, str.tostring(error_days) + " (" + str.tostring(error_rate, "#.##") + "%)", text_color=errorColor, text_size=size.small)

// Trend Indicator Plots
plot(or_start ? na : session_sma, "Session SMA", color=showSMA ? smaColor : na, linewidth=2)
plot(or_start ? na : session_ema, "Session EMA", color=showEMA ? emaColor : na, linewidth=2)
plot(or_start ? na : session_rma, "Session RMA", color=showRMA ? rmaColor : na, linewidth=2)
plot(or_start ? na : session_wma, "Session WMA", color=showWMA ? wmaColor : na, linewidth=2)

// Session Anchor VWAP plot
plot(or_start ? na : session_anchor_vwap_val, "Session Anchor VWAP", color=showVWAP ? vwapColor : na, linewidth=2)

// Target Generation
if not or_sesh and or_token
    if up_count < up_max and tTog
        for i = (up_count + 1) to up_max 
            up_targs.push(target.new(
              line.new(bar_index - 1, (orh + orw * tPer * i), bar_index, (orh + (orw * tPer * i)), 
                      color = green, style = linestyle(tStyle)),
              label.new(bar_index, (orh + orw * tPer * i), text = str.tostring(i), 
                       tooltip = str.tostring(orh + orw * tPer * i, format.mintick), 
                       style = label.style_label_left, color = invis, 
                       textcolor = color.new(green, 0), size = txtSize)))
            if i == up_max
                up_count := up_max
                
    if down_count < down_max and tTog
        for i = (down_count + 1) to down_max
            down_targs.push(target.new(
              line.new(bar_index - 1, (orl - orw * tPer * i), bar_index, (orl - (orw * tPer * i)), 
                      color = red, style = linestyle(tStyle)),
              label.new(bar_index, (orl - orw * tPer * i), text = str.tostring(i), 
                       tooltip = str.tostring(orl - orw * tPer * i, format.mintick), 
                       style = label.style_label_left, color = invis, 
                       textcolor = color.new(red, 0), size = txtSize)))
            if i == down_max
                down_count := down_max

// Target Display Logic
if tDispType == "Extended" and tTog
    for targ in up_targs
        targ.ln.set_x2(bar_index)
        targ.lab.set_x(bar_index)
    for targ in down_targs
        targ.ln.set_x2(bar_index)
        targ.lab.set_x(bar_index) 

if tDispType == "Adaptive" and tTog
    for targ in up_targs
        if targ.ln.get_y1() <= (orh + (orw * tPer * (up_cur))) and targ.ln.get_y1() >= (orh + (orw * tPer * (up_cur - 2)))
            targ.ln.set_x2(bar_index + 1)
            targ.lab.set_x(bar_index + 1)
    for targ in down_targs
        if targ.ln.get_y1() <= (orl - (orw * tPer * (down_cur - 2))) and targ.ln.get_y1() >= (orl - (orw * tPer * (down_cur)))
            targ.ln.set_x2(bar_index + 1)
            targ.lab.set_x(bar_index + 1)

// Breakout Signals Display
if up_signal and sigTog and is_tradable_day
    signals.push(label.new(bar_index, orl,
      style = label.style_label_center, 
      text = "\n▲", 
      color = invis, 
      textcolor = upSigColor, 
      size = sigSize))

if down_signal and sigTog and is_tradable_day
    signals.push(label.new(bar_index, orh,
      style = label.style_label_center, 
      text = "▼\n",
      color = invis, 
      textcolor = downSigColor, 
      size = sigSize))